def query_dataframe(input: QueryDataFrameInput) -> str:
    # Extract parameters
    liquidity_variable_input = input.liquidity_variable.lower().strip()
    time_to_maturity = input.time_to_maturity
    region = input.region
    fi_nonfi = input.fi_nonfi
    ig_nonig = input.ig_nonig

    # Map liquidity_variable
    liquidity_variable_mapping = {
        'japanese government bond': 'jp government bonds',
        'uk corporate bond': 'uk corporate bonds',
        'australian government bond': 'aus government bonds',
        # Add more mappings as needed
    }

    liquidity_variable = liquidity_variable_mapping.get(liquidity_variable_input, liquidity_variable_input)

    # Normalize DataFrame columns for consistent comparison
    df_liquidity['Liquidity Variable'] = df_liquidity['Liquidity Variable'].str.lower().str.strip()
    df_liquidity['Region'] = df_liquidity['Region'].str.lower().str.strip()
    df_liquidity['FI_NonFI'] = df_liquidity['FI_NonFI'].str.lower().str.strip()
    df_liquidity['IG_NonIG'] = df_liquidity['IG_NonIG'].str.lower().str.strip()
    df_liquidity['Time to Maturity'] = df_liquidity['Time to Maturity'].str.lower().str.strip()

    # Apply filters
    query_df = df_liquidity.copy()

    # Liquidity Variable filter
    query_df = query_df[query_df['Liquidity Variable'] == liquidity_variable]
    if query_df.empty:
        return f"No data found for Liquidity Variable: {liquidity_variable_input}"

    # Time to Maturity mapping and filter
    if time_to_maturity:
        time_to_maturity = time_to_maturity.lower().strip()

        # Map specific years to '< 5 years' or '> 5 years'
        ttm_mapping = {
            '1 year': '< 5 years',
            '2 years': '< 5 years',
            '3 years': '< 5 years',
            '4 years': '< 5 years',
            '5 years': '< 5 years',
            '6 years': '> 5 years',
            '7 years': '> 5 years',
            '8 years': '> 5 years',
            '9 years': '> 5 years',
            '10 years': '> 5 years',
        }
        mapped_ttm = ttm_mapping.get(time_to_maturity, time_to_maturity)
        query_df = query_df[query_df['Time to Maturity'] == mapped_ttm]
        if query_df.empty:
            return f"No data found for Time to Maturity: {time_to_maturity}"

    # Region filter
    if region:
        region = region.lower().strip()
        query_df = query_df[query_df['Region'] == region]
        if query_df.empty:
            return f"No data found for Region: {region}"

    # FI_NonFI filter
    if fi_nonfi:
        fi_nonfi = fi_nonfi.lower().strip()
        query_df = query_df[query_df['FI_NonFI'] == fi_nonfi]
        if query_df.empty:
            return f"No data found for FI_NonFI: {fi_nonfi}"

    # IG_NonIG filter
    if ig_nonig:
        ig_nonig = ig_nonig.lower().strip()
        query_df = query_df[query_df['IG_NonIG'] == ig_nonig]
        if query_df.empty:
            return f"No data found for IG_NonIG: {ig_nonig}"

    if query_df.empty:
        return "No data found for the given parameters."

    # Limit DataFrame to first 10 columns
    query_df = query_df.iloc[:, :10]

    # Convert DataFrame to a string representation
    result_table = query_df.to_markdown(index=False)

    # Return the result as a string
    return f"Here are the results based on your query:\n\n{result_table}"


-------
Option 1 (multi-retriever):
from langchain.chains import RetrievalQA
from langchain.retrievers.multi_query import MultiQueryRetriever

# Initialize the multi-query retriever
multi_query_retriever = MultiQueryRetriever.from_llm(
    retriever=vectorstore.as_retriever(search_kwargs={"k": 10}),
    llm=llm
)

# Create the RetrievalQA chain
qa_chain = RetrievalQA.from_chain_type(
    llm=llm,
    chain_type="stuff",
    retriever=multi_query_retriever
)

Option 2 (bm25):
from langchain.retrievers import BM25Retriever
from langchain.docstore.document import Document
bm25_retriever = BM25Retriever.from_documents(documents)
bm25_retriever.k = 10
# Initialize the vectorstore retriever
vectorstore_retriever = vectorstore.as_retriever(search_kwargs={"k": 10})

from typing import List
from langchain.schema import BaseRetriever

class EnsembleRetriever(BaseRetriever):
    def __init__(self, retrievers: List[BaseRetriever], weights: List[float]):
        self.retrievers = retrievers
        self.weights = weights

    def get_relevant_documents(self, query: str) -> List[Document]:
        # Get results from each retriever
        results = []
        for retriever, weight in zip(self.retrievers, self.weights):
            docs = retriever.get_relevant_documents(query)
            # Assign a score based on the weight
            for doc in docs:
                doc.metadata['score'] = doc.metadata.get('score', 0) + weight
            results.extend(docs)
        
        # Remove duplicates by doc ID or content
        unique_results = {}
        for doc in results:
            key = doc.metadata.get('source', doc.page_content)
            if key in unique_results:
                # If already exists, sum the scores
                unique_results[key].metadata['score'] += doc.metadata['score']
            else:
                unique_results[key] = doc

        # Sort documents by the combined score
        sorted_docs = sorted(unique_results.values(), key=lambda d: d.metadata['score'], reverse=True)

        # Return top k documents
        top_k = 5  # Adjust as needed
        return sorted_docs[:top_k]

    async def aget_relevant_documents(self, query: str) -> List[Document]:
        # Optional: Implement asynchronous retrieval if needed
        pass

# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[vectorstore_retriever, bm25_retriever],
    weights=[0.7, 0.3]  # Adjust weights as needed
)

# Create the RetrievalQA chain with the ensemble retriever
qa_chain = RetrievalQA.from_chain_type(
    llm=llm,
    chain_type="stuff",
    retriever=ensemble_retriever
)

def retrieve_documents(query: str) -> str:
    # Use the qa_chain to retrieve and answer the query
    result = qa_chain.run(query)
    return result
