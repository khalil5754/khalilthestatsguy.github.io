# Additional import for seaborn
import seaborn as sns

# Set seaborn style and palette
sns.set(style="whitegrid")
palette = sns.color_palette("pastel")
def visualize_fx_rates(input: VisualizeFXRatesInput) -> str:
    # Extract parameters
    currency_codes = [code.upper().strip() for code in input.currency_codes]
    start_period = input.start_period
    end_period = input.end_period
    comparison_type = input.comparison_type.lower() if input.comparison_type else None
    chart_type = input.chart_type.lower()

    # Validate inputs
    if not currency_codes:
        return "Missing required parameter: currency_codes."

    # Parse the 'Date' column in the data using the correct format
    df_fx_rates_melted['Date'] = pd.to_datetime(df_fx_rates_melted['Date'], format='%b-%y')

    # Handle 'YTD' or missing periods
    if (start_period is None or 'ytd' in start_period.lower()) and (end_period is None or 'ytd' in end_period.lower()):
        # Set to earliest and latest dates in the data
        start_date = df_fx_rates_melted['Date'].min()
        end_date = df_fx_rates_melted['Date'].max()
    else:
        # Extract the year(s) from the data
        data_years = df_fx_rates_melted['Date'].dt.year.unique()
        if len(data_years) == 1:
            data_year = data_years[0]
        else:
            # Handle multiple years if necessary
            data_year = data_years.max()  # You might want to prompt the user for the year

        # Convert periods to datetime
        try:
            start_date_str = f"{start_period}-{str(data_year)[-2:]}"
            end_date_str = f"{end_period}-{str(data_year)[-2:]}"
            start_date = pd.to_datetime(start_date_str, format='%b-%y')
            end_date = pd.to_datetime(end_date_str, format='%b-%y')
        except Exception as e:
            return f"Invalid date format: {e}"

    # Ensure start_date is before end_date
    if start_date > end_date:
        start_date, end_date = end_date, start_date

    # Filter data for the given currency codes
    df_filtered = df_fx_rates_melted[
        df_fx_rates_melted['Currency'].isin(currency_codes)
    ]

    if df_filtered.empty:
        return "No data available for the given currency codes."

    # Filter dates
    df_filtered = df_filtered[
        (df_filtered['Date'] >= start_date) & (df_filtered['Date'] <= end_date)
    ]

    if df_filtered.empty:
        return "No data available for the given date range."

    # Pivot data for easier calculation
    df_pivot = df_filtered.pivot_table(
        index='Date', columns='Currency', values='FX Rate'
    )

    # Ensure data types are numeric
    df_pivot = df_pivot.apply(pd.to_numeric, errors='coerce')

    # Drop columns with all NaN values
    df_pivot.dropna(axis=1, how='all', inplace=True)

    if df_pivot.empty:
        return "No valid FX Rate data available after processing."

    # Perform comparison
    if comparison_type == 'difference':
        df_diff = df_pivot.diff()
        title = f"Difference in FX Rates Over Time"
    elif comparison_type == 'percentage difference':
        df_diff = df_pivot.pct_change() * 100
        title = f"Percentage Difference in FX Rates Over Time"
    else:
        df_diff = df_pivot
        title = f"FX Rates Over Time"

    # Drop NaN values from df_diff
    df_diff.dropna(inplace=True)

    if df_diff.empty:
        return "No data available after calculating differences."

    # Plotting
    plt.figure(figsize=(14, 8))
    if chart_type == 'bar':
        # For bar chart, plot the final differences
        df_diff.iloc[-1].plot(kind='bar', legend=False, color=palette)
        plt.xlabel('Currency Code')
        plt.ylabel('Percentage Difference (%)' if comparison_type == 'percentage difference' else 'FX Rate Difference')
    else:
        # For line chart, plot differences over time
        ax = df_diff.plot(marker='o', linewidth=2, color=palette)
        plt.xlabel('Date')
        plt.ylabel('Percentage Difference (%)' if comparison_type == 'percentage difference' else 'FX Rate')
    plt.title(title)
    plt.grid(True)
    plt.show()

    return ""



---------------------------------------------------------------------

def query_dataframe(input: QueryDataFrameInput) -> str:
    # Extract parameters
    liquidity_variable_input = input.liquidity_variable.lower().strip()
    time_to_maturity = input.time_to_maturity
    region = input.region
    fi_nonfi = input.fi_nonfi
    ig_nonig = input.ig_nonig

    # Map liquidity_variable
    liquidity_variable_mapping = {
        'japanese government bonds': 'jp government bonds',
        'japanese government bond': 'jp government bonds',
        'uk corporate bond': 'uk corporate bonds',
        'uk government bond': 'uk government bonds',
        'uk government bonds': 'uk government bonds',
        'german government bonds': 'german government bonds',
        # Add more mappings as needed
    }

    liquidity_variable = liquidity_variable_mapping.get(liquidity_variable_input, liquidity_variable_input)

    # Normalize DataFrame columns for consistent comparison
    df_liquidity['Liquidity Variable'] = df_liquidity['Liquidity Variable'].str.lower().str.strip()
    df_liquidity['Region'] = df_liquidity['Region'].str.lower().str.strip()
    df_liquidity['FI_NonFI'] = df_liquidity['FI_NonFI'].str.lower().str.strip()
    df_liquidity['IG_NonIG'] = df_liquidity['IG_NonIG'].str.lower().str.strip()
    df_liquidity['Time to Maturity'] = df_liquidity['Time to Maturity'].str.lower().str.strip()

    # Apply filters
    query_df = df_liquidity.copy()

    # Liquidity Variable filter
    query_df = query_df[query_df['Liquidity Variable'] == liquidity_variable]
    if query_df.empty:
        return f"No data found for Liquidity Variable: {liquidity_variable_input}"

    # Time to Maturity mapping and filter (only if specified)
    if time_to_maturity:
        time_to_maturity = time_to_maturity.lower().strip()

        # Map specific years to the actual values in your DataFrame
        ttm_mapping = {
            '1 year': '1 year',
            '2 years': '2 years',
            '3 years': '3 years',
            '4 years': '4 years',
            '5 years': '5 years',
            'less than 5 years': '< 5 years',
            'more than 5 years': '> 5 years',
            # Add more mappings as per your DataFrame
        }
        mapped_ttm = ttm_mapping.get(time_to_maturity, time_to_maturity)
        query_df = query_df[query_df['Time to Maturity'] == mapped_ttm]
        if query_df.empty:
            return f"No data found for Time to Maturity: {time_to_maturity}"

    # Region filter
    if region:
        region = region.lower().strip()
        query_df = query_df[query_df['Region'] == region]
        if query_df.empty:
            return f"No data found for Region: {region}"

    # FI_NonFI filter
    if fi_nonfi:
        fi_nonfi = fi_nonfi.lower().strip()
        query_df = query_df[query_df['FI_NonFI'] == fi_nonfi]
        if query_df.empty:
            return f"No data found for FI_NonFI: {fi_nonfi}"

    # IG_NonIG filter
    if ig_nonig:
        ig_nonig = ig_nonig.lower().strip()
        query_df = query_df[query_df['IG_NonIG'] == ig_nonig]
        if query_df.empty:
            return f"No data found for IG_NonIG: {ig_nonig}"

    if query_df.empty:
        return "No data found for the given parameters."

    # Select only the specified columns
    columns_of_interest = ['Liquidity Variable', 'Time to Maturity', 'Region', 'Haircut']
    query_df = query_df[columns_of_interest]

    # Convert DataFrame to string for output
    result_str = query_df.to_string(index=False)

    return f"{result_str}\n\nHere are the results based on your query for '{input.liquidity_variable}'."
