# app.py

# Imports
import os
import pandas as pd
import openai
from langchain.chat_models import ChatOpenAI
from langchain.agents import AgentExecutor
from langchain.memory import ConversationBufferMemory
from langchain.tools import StructuredTool
from langchain.schema import SystemMessage
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.document_loaders import DirectoryLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.docstore.document import Document
from langchain.retrievers import BM25Retriever, MultiVectorRetriever
from langchain.agents import OpenAIFunctionsAgent
from pydantic import BaseModel, Field
from typing import Optional, List
import matplotlib.pyplot as plt
from IPython.display import clear_output
import json

# Initialize conversation history
conversation_history = []

# Initialize memory
memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)

# Initialize the LLM with system prompt
openai_api_key = os.environ.get("OPENAI_API_KEY")  # Replace with your method
llm = ChatOpenAI(
    model_name="gpt-4-0613",  # Ensure function calling support
    temperature=0,
    openai_api_key=openai_api_key,
)

# System prompt to guide the LLM
system_prompt = """
You are a helpful assistant for the corporate treasury department.

When a user asks a question, determine the type of question:

1. If the question is about 'haircut' or 'FTP rate' (contains the keyword 'haircut' or 'FTP'), collect necessary parameters and call the 'compute_ftp_rate' function to get data.

2. If the question is about FX Rates (e.g., involves currencies, exchange rates, dates), collect necessary parameters and call the 'visualize_fx_rates' function to generate the requested visualization.

3. If the question is about liquidity variables, time to maturity, regions, etc., collect necessary parameters and call the 'query_dataframe' function.

4. For other questions, use the 'retrieve_documents' function to search the corpus for relevant information, and provide an informative answer.

Always ensure that you are polite and helpful. If any parameters are missing for a function, ask the user for the missing information.

Examples:

- User: "What is the haircut for UK government bonds?"
  Assistant: Calls 'query_dataframe' with liquidity_variable='UK government bonds', time_to_maturity=None, region=None, fi_nonfi=None, ig_nonig=None.

- User: "Show me data for German government bonds with a time to maturity of 1 year."
  Assistant: Calls 'query_dataframe' with liquidity_variable='German government bonds', time_to_maturity='1 year', region=None, fi_nonfi=None, ig_nonig=None.

When displaying visualizations, do not output any text.
"""

# Load your DataFrames
# Liquidity Data
df_liquidity = pd.read_csv('liquidity_data.csv')  # Replace with your actual CSV file path
df_liquidity['Liquidity Variable'] = df_liquidity['Liquidity Variable'].str.lower().str.strip()

# FX Rates Data
df_fx_rates = pd.read_csv('FX_Rates.csv')  # Replace with your actual CSV file path

# Preprocess FX Rates Data
# Melt the DataFrame to have dates in a single column
date_columns = [col for col in df_fx_rates.columns if '-' in col]
df_fx_rates_melted = df_fx_rates.melt(
    id_vars=['Currency', 'Name'],
    value_vars=date_columns,
    var_name='Date',
    value_name='FX Rate'
)

# Normalize Currency codes
df_fx_rates_melted['Currency'] = df_fx_rates_melted['Currency'].str.upper().str.strip()

# Convert Date column to datetime
# Adjust the date parsing format to match your data
df_fx_rates_melted['Date'] = pd.to_datetime(df_fx_rates_melted['Date'], format='%b-%y')

# FLAME Data for FTP computation
df_flame = pd.read_excel('FLAME_data_cleaned.xlsx')
# Convert rates from bps to percentages where necessary
df_flame['Short Term Unsecured Rate'] = df_flame['Short Term Unsecured Rate'] / 10000  # bps to decimal
df_flame['Long Term Funding Rate'] = df_flame['Long Term Funding Rate'] / 10000  # bps to decimal

# Define input schemas using Pydantic models

class QueryDataFrameInput(BaseModel):
    liquidity_variable: str = Field(description="The liquidity variable.")
    time_to_maturity: Optional[str] = Field(default=None, description="The time to maturity.")
    region: Optional[str] = Field(default=None, description="The region.")
    fi_nonfi: Optional[str] = Field(default=None, description="FI or NonFI.")
    ig_nonig: Optional[str] = Field(default=None, description="IG or NonIG.")

class VisualizeFXRatesInput(BaseModel):
    currency_codes: List[str] = Field(description="List of currency codes.")
    start_period: Optional[str] = Field(default=None, description="Start period (e.g., 'January'). If 'YTD' is specified, it will be set to earliest month in data.")
    end_period: Optional[str] = Field(default=None, description="End period (e.g., 'August'). If 'YTD' is specified, it will be set to latest month in data.")
    comparison_type: Optional[str] = Field(default='difference', description="'difference' or 'percentage difference'.")
    chart_type: Optional[str] = Field(default='line', description="'line' or 'bar'.")

class ComputeFTPInput(BaseModel):
    currency: str = Field(description="Currency code, e.g., 'CAD' for Canadian Dollar.")
    product_type: str = Field(description="Product type, e.g., 'Equity - REIT'.")

# Function to visualize FX rates
def visualize_fx_rates(input: VisualizeFXRatesInput) -> str:
    # Extract parameters
    currency_codes = [code.upper().strip() for code in input.currency_codes]
    start_period = input.start_period
    end_period = input.end_period
    comparison_type = input.comparison_type.lower()
    chart_type = input.chart_type.lower()

    # Validate inputs
    if not currency_codes:
        return "Missing required parameter: currency_codes."

    # Handle 'YTD' or missing periods
    if (start_period is None or 'ytd' in start_period.lower()) and (end_period is None or 'ytd' in end_period.lower()):
        # Set to earliest and latest dates in the data
        start_date = df_fx_rates_melted['Date'].min()
        end_date = df_fx_rates_melted['Date'].max()
    else:
        # Convert periods to datetime
        try:
            start_date = pd.to_datetime(start_period, format='%B')
            end_date = pd.to_datetime(end_period, format='%B')
            # Assign the year from the data
            data_year = df_fx_rates_melted['Date'].dt.year.unique()[0]
            start_date = start_date.replace(year=data_year)
            end_date = end_date.replace(year=data_year)
        except Exception as e:
            return f"Invalid date format: {e}"

    # Ensure start_date is before end_date
    if start_date > end_date:
        start_date, end_date = end_date, start_date

    # Filter data for the given currency codes
    df_filtered = df_fx_rates_melted[
        df_fx_rates_melted['Currency'].isin(currency_codes)
    ]

    if df_filtered.empty:
        return "No data available for the given currency codes."

    # Filter dates
    df_filtered = df_filtered[
        (df_filtered['Date'] >= start_date) & (df_filtered['Date'] <= end_date)
    ]

    if df_filtered.empty:
        return "No data available for the given date range."

    # Pivot data for easier calculation
    df_pivot = df_filtered.pivot_table(
        index='Date', columns='Currency', values='FX Rate'
    )

    # Ensure data types are numeric
    df_pivot = df_pivot.apply(pd.to_numeric, errors='coerce')

    # Drop columns with all NaN values
    df_pivot.dropna(axis=1, how='all', inplace=True)

    if df_pivot.empty:
        return "No valid FX Rate data available after processing."

    # Perform comparison
    if comparison_type == 'difference':
        df_diff = df_pivot.diff()
        title = f"Difference in FX Rates Over Time"
    elif comparison_type == 'percentage difference':
        df_diff = df_pivot.pct_change() * 100
        title = f"Percentage Difference in FX Rates Over Time"
    else:
        df_diff = df_pivot
        title = f"FX Rates Over Time"

    # Drop NaN values from df_diff
    df_diff.dropna(inplace=True)

    if df_diff.empty:
        return "No data available after calculating differences."

    # Plotting
    plt.figure(figsize=(10, 6))
    if chart_type == 'bar':
        # For bar chart, plot the final differences
        df_diff.iloc[-1].plot(kind='bar', legend=False)
        plt.xlabel('Currency Code')
        plt.ylabel('Percentage Difference (%)' if 'percentage' in comparison_type else 'FX Rate Difference')
    else:
        # For line chart, plot differences over time
        df_diff.plot()
        plt.xlabel('Date')
        plt.ylabel('Percentage Difference (%)' if 'percentage' in comparison_type else 'FX Rate')

    plt.title(title)
    plt.show()

    return ""

# Function to query the liquidity DataFrame
def query_dataframe(input: QueryDataFrameInput) -> str:
    # Extract parameters
    liquidity_variable_input = input.liquidity_variable.lower().strip()
    time_to_maturity = input.time_to_maturity
    region = input.region
    fi_nonfi = input.fi_nonfi
    ig_nonig = input.ig_nonig

    # Map liquidity_variable
    liquidity_variable_mapping = {
        'japanese government bond': 'jp government bonds',
        'uk corporate bond': 'uk corporate bonds',
        'uk government bond': 'uk government bonds',
        'uk government bonds': 'uk government bonds',
        'german government bonds': 'german government bonds',
        # Add more mappings as needed
    }

    liquidity_variable = liquidity_variable_mapping.get(liquidity_variable_input, liquidity_variable_input)

    # Normalize DataFrame columns for consistent comparison
    df_liquidity['Liquidity Variable'] = df_liquidity['Liquidity Variable'].str.lower().str.strip()
    df_liquidity['Region'] = df_liquidity['Region'].str.lower().str.strip()
    df_liquidity['FI_NonFI'] = df_liquidity['FI_NonFI'].str.lower().str.strip()
    df_liquidity['IG_NonIG'] = df_liquidity['IG_NonIG'].str.lower().str.strip()
    df_liquidity['Time to Maturity'] = df_liquidity['Time to Maturity'].str.lower().str.strip()

    # Apply filters
    query_df = df_liquidity.copy()

    # Liquidity Variable filter
    query_df = query_df[query_df['Liquidity Variable'] == liquidity_variable]
    if query_df.empty:
        return f"No data found for Liquidity Variable: {liquidity_variable_input}"

    # Time to Maturity mapping and filter (only if specified)
    if time_to_maturity:
        time_to_maturity = time_to_maturity.lower().strip()

        # Map specific years to the actual values in your DataFrame
        ttm_mapping = {
            '1 year': '1 year',
            '2 years': '2 years',
            '3 years': '3 years',
            '4 years': '4 years',
            '5 years': '5 years',
            'less than 5 years': '< 5 years',
            'more than 5 years': '> 5 years',
            # Add more mappings as per your DataFrame
        }
        mapped_ttm = ttm_mapping.get(time_to_maturity, time_to_maturity)
        query_df = query_df[query_df['Time to Maturity'] == mapped_ttm]
        if query_df.empty:
            return f"No data found for Time to Maturity: {time_to_maturity}"

    # Region filter
    if region:
        region = region.lower().strip()
        query_df = query_df[query_df['Region'] == region]
        if query_df.empty:
            return f"No data found for Region: {region}"

    # FI_NonFI filter
    if fi_nonfi:
        fi_nonfi = fi_nonfi.lower().strip()
        query_df = query_df[query_df['FI_NonFI'] == fi_nonfi]
        if query_df.empty:
            return f"No data found for FI_NonFI: {fi_nonfi}"

    # IG_NonIG filter
    if ig_nonig:
        ig_nonig = ig_nonig.lower().strip()
        query_df = query_df[query_df['IG_NonIG'] == ig_nonig]
        if query_df.empty:
            return f"No data found for IG_NonIG: {ig_nonig}"

    if query_df.empty:
        return "No data found for the given parameters."

    # Select only the specified columns
    columns_of_interest = ['Liquidity Variable', 'Time to Maturity', 'Region', 'Haircut']
    query_df = query_df[columns_of_interest]

    # Convert DataFrame to string for output
    result_str = query_df.to_string(index=False)

    return f"Here are the results based on your query:\n{result_str}"

# Function to compute FTP rate
def compute_ftp_rate(input: ComputeFTPInput) -> str:
    currency_input = input.currency.upper().strip()
    product_type_input = input.product_type.strip()

    # Map user inputs to DataFrame values
    product_type_mapping = {
        'reit equities': 'Equity - REIT',
        'reit equity': 'Equity - REIT',
        # Add more mappings as needed
    }

    product_type = product_type_mapping.get(product_type_input.lower(), product_type_input)

    # Filter DataFrame based on inputs
    df_filtered = df_flame[
        (df_flame['Currency'] == currency_input) &
        (df_flame['Product Type'] == product_type)
    ]

    if df_filtered.empty:
        return f"No data found for Currency: {currency_input} and Product Type: {product_type}"

    # Get the first matching row
    row = df_filtered.iloc[0]

    # Extract values
    term_funding_haircut = row['Term Funding Haircut']
    short_term_unsecured_rate = row['Short Term Unsecured Rate']
    long_term_funding_rate = row['Long Term Funding Rate']

    # Compute FTP Rate
    ftp_rate = (1 - term_funding_haircut) * short_term_unsecured_rate + term_funding_haircut * long_term_funding_rate

    # Convert rates to percentages for display
    term_funding_haircut_pct = term_funding_haircut * 100
    short_term_unsecured_rate_pct = short_term_unsecured_rate * 100
    long_term_funding_rate_pct = long_term_funding_rate * 100
    ftp_rate_pct = ftp_rate * 100

    # Prepare the formula string
    formula_str = f"FTP Rate = (1 - Term Funding Haircut) * Short Term Unsecured Rate + Term Funding Haircut * Long Term Funding Rate"

    # Prepare the calculation string
    calculation_str = f"FTP Rate = (1 - {term_funding_haircut_pct:.2f}%) * {short_term_unsecured_rate_pct:.2f}% + {term_funding_haircut_pct:.2f}% * {long_term_funding_rate_pct:.2f}% = {ftp_rate_pct:.2f}%"

    return f"The FTP rate for {product_type} in {currency_input} is {ftp_rate_pct:.2f}%.\n\nFormula:\n{formula_str}\n\nCalculation:\n{calculation_str}"

# Document Retrieval Setup
# Load documents
loader = DirectoryLoader('documents', glob='*.txt')  # Replace 'documents' with your directory
documents = loader.load()

# Split documents using a single optimized chunk size
text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
docs = text_splitter.split_documents(documents)

# Initialize embeddings
embeddings = OpenAIEmbeddings(openai_api_key=openai_api_key)

# Create Chroma vector store
vectorstore = Chroma.from_documents(docs, embeddings)

# Initialize BM25 retriever
bm25_retriever = BM25Retriever.from_documents(docs)

# Create MultiVectorRetriever
hybrid_retriever = MultiVectorRetriever(
    retrievers=[vectorstore.as_retriever(), bm25_retriever],
    verbose=True,
)

# Define the retrieve_documents function
def retrieve_documents(query):
    # Retrieve documents using the hybrid retriever
    docs = hybrid_retriever.get_relevant_documents(query)
    # Combine retrieved documents into a single string
    retrieved_text = '\n'.join([doc.page_content for doc in docs])
    return retrieved_text

# Define the tools using StructuredTool
tools = [
    StructuredTool.from_function(
        func=query_dataframe,
        name="query_dataframe",
        description="Queries the liquidity DataFrame based on parameters.",
    ),
    StructuredTool.from_function(
        func=visualize_fx_rates,
        name="visualize_fx_rates",
        description="Visualizes FX Rates data based on user parameters.",
    ),
    StructuredTool.from_function(
        func=retrieve_documents,
        name="retrieve_documents",
        description="Retrieves relevant documents from the corpus.",
    ),
    StructuredTool.from_function(
        func=compute_ftp_rate,
        name="compute_ftp_rate",
        description="Computes the FTP rate based on currency and product type.",
    ),
]

# Create the agent using OpenAIFunctionsAgent
agent = OpenAIFunctionsAgent.from_llm_and_tools(
    llm=llm,
    tools=tools,
    system_prompt=system_prompt,
    extra_prompt_messages=[],
)
agent_executor = AgentExecutor.from_agent_and_tools(
    agent=agent,
    tools=tools,
    verbose=True,
    memory=memory,
)

# Get user input from the Databricks widget
dbutils.widgets.text("Text Box", "", "Enter your query here")
user_input = dbutils.widgets.get("Text Box")

if user_input:
    # Append user's message to conversation history
    conversation_history.append({"role": "user", "content": user_input})

    # Run the agent with exception handling
    print("Assistant is typing...")
    try:
        assistant_response = agent_executor.run(
            input=user_input
        )
    except Exception as e:
        print(f"An error occurred: {str(e)}")
        assistant_response = "I'm sorry, I encountered an error."

    # Append assistant's response to conversation history
    conversation_history.append({"role": "assistant", "content": assistant_response})

    # Clear the widget value for the next input
    dbutils.widgets.remove("Text Box")
    dbutils.widgets.text("Text Box", "", "Enter your query here")

    # Display the assistant's response if it's not empty
    if assistant_response:
        print("\nAssistant:")
        print(assistant_response)
