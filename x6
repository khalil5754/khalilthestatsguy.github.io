class VisualizeFXRatesInput(BaseModel):
    currency_codes: List[str] = Field(description="List of currency codes.")
    start_period: Optional[str] = Field(default=None, description="Start period (e.g., 'January'). If 'YTD' is specified, it will be set to 'January'.")
    end_period: Optional[str] = Field(default=None, description="End period (e.g., 'August'). If 'YTD' is specified, it will be set to 'August'.")
    comparison_type: Optional[str] = Field(default='difference', description="'difference' or 'percentage difference'.")
    chart_type: Optional[str] = Field(default='line', description="'line' or 'bar'.")
    trend_line: Optional[bool] = Field(default=False, description="Set to True to include a trend line in the graph.")


def visualize_fx_rates(input: VisualizeFXRatesInput) -> str:
    import matplotlib.pyplot as plt
    import matplotlib.dates as mdates
    import numpy as np
    from sklearn.linear_model import LinearRegression
    import matplotlib.cm as cm

    # Extract parameters
    currency_codes = input.currency_codes
    start_period = input.start_period
    end_period = input.end_period
    comparison_type = input.comparison_type.lower()
    chart_type = input.chart_type.lower()
    trend_line = input.trend_line

    # Validate inputs
    if not currency_codes:
        return "Missing required parameter: currency_codes."
    
    # Handle 'YTD' or missing periods
    if start_period is None or end_period is None or 'ytd' in (start_period.lower(), end_period.lower()):
        start_period = 'January'
        end_period = 'August'

    # Convert periods to datetime
    try:
        start_date = pd.to_datetime(f"2023 {start_period}", format='%Y %B')
        end_date = pd.to_datetime(f"2023 {end_period}", format='%Y %B')
    except Exception as e:
        return f"Invalid date format: {e}"

    # Ensure start_date is before end_date
    if start_date > end_date:
        start_date, end_date = end_date, start_date

    # Convert 'Date' column to datetime if not already
    if not pd.api.types.is_datetime64_any_dtype(df_fx_rates_melted['Date']):
        df_fx_rates_melted['Date'] = pd.to_datetime(df_fx_rates_melted['Date'], errors='coerce')
        # Check for NaT values and drop them
        df_fx_rates_melted.dropna(subset=['Date'], inplace=True)

    # Ensure 'Currency' codes are uppercase
    df_fx_rates_melted['Currency'] = df_fx_rates_melted['Currency'].str.upper()
    currency_codes = [code.upper() for code in currency_codes]

    # Filter data for the given currency codes
    df_filtered = df_fx_rates_melted[
        df_fx_rates_melted['Currency'].isin(currency_codes)
    ]

    if df_filtered.empty:
        return "No data available for the given currency codes."

    # Filter dates
    df_filtered = df_filtered[
        (df_filtered['Date'] >= start_date) & (df_filtered['Date'] <= end_date)
    ]

    if df_filtered.empty:
        return "No data available for the given date range."

    # Pivot data for easier calculation
    df_pivot = df_filtered.pivot_table(
        index='Date', columns='Currency', values='FX Rate'
    )

    # Ensure data types are numeric
    df_pivot = df_pivot.apply(pd.to_numeric, errors='coerce')

    # Drop columns with all NaN values
    df_pivot.dropna(axis=1, how='all', inplace=True)

    if df_pivot.empty:
        return "No valid FX Rate data available after processing."

    # Plotting
    if chart_type == 'line':
        # Calculate month-over-month percentage differences
        df_pct_change = df_pivot.pct_change().dropna() * 100

        if df_pct_change.empty:
            return "No data available after calculating month-over-month percentage differences."

        title = f"Month-over-Month Percentage Difference in FX Rates from {start_period} to {end_period}"

        # Plotting
        fig, ax = plt.subplots(figsize=(12, 6))
        df_pct_change.plot(ax=ax, marker='o', linewidth=2)

        # Remove the line color customization to let Matplotlib assign different colors
        # for line in ax.get_lines():
        #     line.set_color('steelblue')

        # Highlight the line with the highest cumulative change
        cumulative_changes = df_pct_change.sum()
        max_currency = cumulative_changes.idxmax()
        max_line = ax.get_lines()[df_pct_change.columns.get_loc(max_currency)]
        max_line.set_linewidth(3)
        # Optionally change its color
        # max_line.set_color('lightcoral')

        # Annotate the highest line
        max_value = df_pct_change[max_currency].max()
        max_date = df_pct_change[max_currency].idxmax()
        ax.annotate(
            f'Highest: {max_currency}',
            xy=(max_date, max_value),
            xytext=(0, 10),
            textcoords='offset points',
            ha='center',
            va='bottom',
            fontsize=10,
            fontweight='bold',
            color='red'
        )

        # Add trend lines if specified
        if trend_line:
            # For each currency, add a trend line
            for currency in df_pct_change.columns:
                x_dates = df_pct_change.index
                x_vals = mdates.date2num(x_dates)
                y_vals = df_pct_change[currency].values
                model = LinearRegression()
                model.fit(x_vals.reshape(-1, 1), y_vals)
                trend = model.predict(x_vals.reshape(-1, 1))
                ax.plot(x_dates, trend, linestyle='--', color='grey')

        ax.set_title(title)
        ax.set_ylabel('Percentage Change (%)')
        ax.set_xlabel('Date')

        # Format x-axis dates
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
        ax.xaxis.set_major_locator(mdates.MonthLocator())
        plt.xticks(rotation=45)

        ax.legend(title='Currency Codes')

        # Improve overall appearance
        ax.grid(True, linestyle='--', alpha=0.5)
        plt.tight_layout()

        # Set x-axis limits to data range
        ax.set_xlim(df_pct_change.index.min(), df_pct_change.index.max())

    else:
        # Handle bar chart or other chart types if necessary
        pass

    # Display the plot
    plt.show()

    return "Here is the visualization as per your request."




def query_dataframe(input: QueryDataFrameInput) -> str:
    # Extract parameters
    liquidity_variable_input = input.liquidity_variable.lower().strip()
    time_to_maturity = input.time_to_maturity
    region = input.region
    fi_nonfi = input.fi_nonfi
    ig_nonig = input.ig_nonig

    # Map liquidity_variable
    liquidity_variable_mapping = {
        'japanese government bond': 'jp government bonds',
        'uk corporate bond': 'uk corporate bonds',
        'australian government bond': 'aus government bonds',
        # Add more mappings as needed
    }

    liquidity_variable = liquidity_variable_mapping.get(liquidity_variable_input, liquidity_variable_input)

    # Normalize DataFrame columns for consistent comparison
    df_liquidity['Liquidity Variable'] = df_liquidity['Liquidity Variable'].str.lower().str.strip()
    df_liquidity['Region'] = df_liquidity['Region'].str.lower().str.strip()
    df_liquidity['FI_NonFI'] = df_liquidity['FI_NonFI'].str.lower().str.strip()
    df_liquidity['IG_NonIG'] = df_liquidity['IG_NonIG'].str.lower().str.strip()
    df_liquidity['Time to Maturity'] = df_liquidity['Time to Maturity'].str.lower().str.strip()

    # Apply filters
    query_df = df_liquidity.copy()

    # Liquidity Variable filter
    query_df = query_df[query_df['Liquidity Variable'] == liquidity_variable]
    if query_df.empty:
        return f"No data found for Liquidity Variable: {liquidity_variable_input}"

    # Time to Maturity mapping and filter
    if time_to_maturity:
        time_to_maturity = time_to_maturity.lower().strip()

        # Map specific years to '< 5 years' or '> 5 years'
        ttm_mapping = {
            '1 year': '< 5 years',
            '2 years': '< 5 years',
            '3 years': '< 5 years',
            '4 years': '< 5 years',
            '5 years': '< 5 years',
            '6 years': '> 5 years',
            '7 years': '> 5 years',
            '8 years': '> 5 years',
            '9 years': '> 5 years',
            '10 years': '> 5 years',
        }
        mapped_ttm = ttm_mapping.get(time_to_maturity, time_to_maturity)
        query_df = query_df[query_df['Time to Maturity'] == mapped_ttm]
        if query_df.empty:
            return f"No data found for Time to Maturity: {time_to_maturity}"

    # Region filter
    if region:
        region = region.lower().strip()
        query_df = query_df[query_df['Region'] == region]
        if query_df.empty:
            return f"No data found for Region: {region}"

    # FI_NonFI filter
    if fi_nonfi:
        fi_nonfi = fi_nonfi.lower().strip()
        query_df = query_df[query_df['FI_NonFI'] == fi_nonfi]
        if query_df.empty:
            return f"No data found for FI_NonFI: {fi_nonfi}"

    # IG_NonIG filter
    if ig_nonig:
        ig_nonig = ig_nonig.lower().strip()
        query_df = query_df[query_df['IG_NonIG'] == ig_nonig]
        if query_df.empty:
            return f"No data found for IG_NonIG: {ig_nonig}"

    if query_df.empty:
        return "No data found for the given parameters."

    # Limit DataFrame to first 10 columns
    query_df = query_df.iloc[:, :10]

    # Display the result DataFrame
    display(query_df)

    return "Here are the results based on your query."
