class VisualizeFXRatesInput(BaseModel):
    currency_codes: List[str] = Field(description="List of currency codes.")
    start_period: Optional[str] = Field(default=None, description="Start period (e.g., 'January'). If 'YTD' is specified, it will be set to 'January'.")
    end_period: Optional[str] = Field(default=None, description="End period (e.g., 'August'). If 'YTD' is specified, it will be set to 'August'.")
    comparison_type: Optional[str] = Field(default='difference', description="'difference' or 'percentage difference'.")
    chart_type: Optional[str] = Field(default='line', description="'line' or 'bar'.")
    trend_line: Optional[bool] = Field(default=False, description="Set to True to include a trend line in the graph.")


def visualize_fx_rates(input: VisualizeFXRatesInput) -> str:
    import matplotlib.pyplot as plt
    import matplotlib.dates as mdates
    import numpy as np
    from sklearn.linear_model import LinearRegression

    # Extract parameters
    currency_codes = input.currency_codes
    start_period = input.start_period
    end_period = input.end_period
    comparison_type = input.comparison_type.lower()
    chart_type = input.chart_type.lower()
    trend_line = input.trend_line

    # Validate inputs
    if not currency_codes:
        return "Missing required parameter: currency_codes."
    
    # Handle 'YTD' or missing periods
    if start_period is None or end_period is None or 'ytd' in (start_period.lower(), end_period.lower()):
        start_period = 'January'
        end_period = 'August'

    # Convert periods to datetime
    try:
        start_date = pd.to_datetime(f"2023 {start_period}", format='%Y %B')
        end_date = pd.to_datetime(f"2023 {end_period}", format='%Y %B')
    except Exception as e:
        return f"Invalid date format: {e}"

    # Ensure start_date is before end_date
    if start_date > end_date:
        start_date, end_date = end_date, start_date

    # Convert 'Date' column to datetime if not already
    if not pd.api.types.is_datetime64_any_dtype(df_fx_rates_melted['Date']):
        df_fx_rates_melted['Date'] = pd.to_datetime(df_fx_rates_melted['Date'], errors='coerce')

    # Ensure 'Currency' codes are uppercase
    df_fx_rates_melted['Currency'] = df_fx_rates_melted['Currency'].str.upper()
    currency_codes = [code.upper() for code in currency_codes]

    # Filter data for the given currency codes
    df_filtered = df_fx_rates_melted[
        df_fx_rates_melted['Currency'].isin(currency_codes)
    ]

    if df_filtered.empty:
        return "No data available for the given currency codes."

    # Filter dates
    df_filtered = df_filtered[
        (df_filtered['Date'] >= start_date) & (df_filtered['Date'] <= end_date)
    ]

    if df_filtered.empty:
        return "No data available for the given date range."

    # Pivot data for easier calculation
    df_pivot = df_filtered.pivot_table(
        index='Date', columns='Currency', values='FX Rate'
    )

    # Ensure data types are numeric
    df_pivot = df_pivot.apply(pd.to_numeric, errors='coerce')

    # Drop columns with all NaN values
    df_pivot.dropna(axis=1, how='all', inplace=True)

    if df_pivot.empty:
        return "No valid FX Rate data available after processing."

    # Plotting
    plt.figure(figsize=(12, 6))

    if chart_type == 'bar':
        if comparison_type == 'difference':
            df_diff = df_pivot.iloc[-1] - df_pivot.iloc[0]
            title = f"Difference in FX Rates between {start_period} and {end_period}"
        elif comparison_type == 'percentage difference':
            df_diff = ((df_pivot.iloc[-1] - df_pivot.iloc[0]) / df_pivot.iloc[0]) * 100
            title = f"Percentage Difference in FX Rates between {start_period} and {end_period}"
        else:
            return "Invalid comparison type. Please specify 'difference' or 'percentage difference'."

        # Drop NaN values from df_diff
        df_diff.dropna(inplace=True)

        if df_diff.empty:
            return "No data available after calculating differences."

        # Refined Bar Plot
        ax = df_diff.plot(kind='bar', color='steelblue', edgecolor='black', linewidth=1)

        # Highlight the highest bar
        max_currency = df_diff.idxmax()
        max_value = df_diff.max()
        bars = ax.patches
        for bar in bars:
            if bar.get_x() + bar.get_width() / 2 == bars[df_diff.index.get_loc(max_currency)].get_x() + bar.get_width() / 2:
                bar.set_color('lightcoral')

        # Annotate the highest value
        plt.annotate(
            f'Highest: {max_currency}',
            xy=(bars[df_diff.index.get_loc(max_currency)].get_x() + bar.get_width() / 2, max_value),
            xytext=(0, 5),
            textcoords='offset points',
            ha='center',
            va='bottom',
            fontsize=10,
            fontweight='bold',
            color='red'
        )

        # Add trend line if specified
        if trend_line:
            # For bar chart, fit a linear trend line
            x_vals = np.arange(len(df_diff))
            y_vals = df_diff.values
            z = np.polyfit(x_vals, y_vals, 1)
            p = np.poly1d(z)
            plt.plot(x_vals, p(x_vals), linestyle='--', color='grey')

        plt.title(title)
        plt.ylabel('Percentage Difference (%)' if 'percentage' in comparison_type else 'FX Rate Difference')
        plt.xlabel('Currency Code')

        # Improve overall appearance
        plt.grid(True, linestyle='--', alpha=0.5, axis='y')
        plt.tight_layout()

    elif chart_type == 'line':
        # Calculate month-over-month percentage differences
        df_pct_change = df_pivot.pct_change().dropna() * 100

        if df_pct_change.empty:
            return "No data available after calculating month-over-month percentage differences."

        title = f"Month-over-Month Percentage Difference in FX Rates from {start_period} to {end_period}"

        # Plotting
        ax = df_pct_change.plot(marker='o', linewidth=2)

        # Customize lines
        for line in ax.get_lines():
            line.set_color('steelblue')

        # Highlight the line with the highest cumulative change
        cumulative_changes = df_pct_change.sum()
        max_currency = cumulative_changes.idxmax()
        max_line = ax.get_lines()[df_pct_change.columns.get_loc(max_currency)]
        max_line.set_color('lightcoral')

        # Annotate the highest line
        max_value = df_pct_change[max_currency].max()
        max_date = df_pct_change[max_currency].idxmax()
        plt.annotate(
            f'Highest: {max_currency}',
            xy=(mdates.date2num(max_date), max_value),
            xytext=(0, 10),
            textcoords='offset points',
            ha='center',
            va='bottom',
            fontsize=10,
            fontweight='bold',
            color='red'
        )

        # Add trend lines if specified
        if trend_line:
            # For each currency, add a trend line
            for currency in df_pct_change.columns:
                x_vals = mdates.date2num(df_pct_change.index)
                y_vals = df_pct_change[currency].values
                model = LinearRegression()
                model.fit(x_vals.reshape(-1, 1), y_vals)
                trend = model.predict(x_vals.reshape(-1, 1))
                plt.plot(df_pct_change.index, trend, linestyle='--', color='grey')

        plt.title(title)
        plt.ylabel('Percentage Change (%)')
        plt.xlabel('Date')

        # Format x-axis dates
        plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
        plt.gca().xaxis.set_major_locator(mdates.MonthLocator())
        plt.xticks(rotation=45)

        plt.legend(title='Currency Codes')

        # Improve overall appearance
        plt.grid(True, linestyle='--', alpha=0.5)
        plt.tight_layout()

    else:
        return "Invalid chart type. Please specify 'line' or 'bar'."

    # Display the plot
    plt.show()

    return "Here is the visualization as per your request."



def query_dataframe(input: QueryDataFrameInput) -> str:
    # Extract parameters
    liquidity_variable_input = input.liquidity_variable.lower().strip()
    time_to_maturity = input.time_to_maturity
    region = input.region
    fi_nonfi = input.fi_nonfi
    ig_nonig = input.ig_nonig

    # Map liquidity_variable
    liquidity_variable_mapping = {
        'japanese government bond': 'jp government bonds',
        'uk corporate bond': 'uk corporate bonds',
        'australian government bond': 'aus government bonds',
        # Add more mappings as needed
    }

    liquidity_variable = liquidity_variable_mapping.get(liquidity_variable_input, liquidity_variable_input)

    # Normalize DataFrame columns for consistent comparison
    df_liquidity['Liquidity Variable'] = df_liquidity['Liquidity Variable'].str.lower().str.strip()
    df_liquidity['Region'] = df_liquidity['Region'].str.lower().str.strip()
    df_liquidity['FI_NonFI'] = df_liquidity['FI_NonFI'].str.lower().str.strip()
    df_liquidity['IG_NonIG'] = df_liquidity['IG_NonIG'].str.lower().str.strip()
    df_liquidity['Time to Maturity'] = df_liquidity['Time to Maturity'].str.lower().str.strip()

    # Apply filters
    query_df = df_liquidity.copy()

    # Liquidity Variable filter
    query_df = query_df[query_df['Liquidity Variable'] == liquidity_variable]
    if query_df.empty:
        return f"No data found for Liquidity Variable: {liquidity_variable_input}"

    # Time to Maturity mapping and filter
    if time_to_maturity:
        time_to_maturity = time_to_maturity.lower().strip()

        # Map specific years to '< 5 years' or '> 5 years'
        ttm_mapping = {
            '1 year': '< 5 years',
            '2 years': '< 5 years',
            '3 years': '< 5 years',
            '4 years': '< 5 years',
            '5 years': '< 5 years',
            '6 years': '> 5 years',
            '7 years': '> 5 years',
            '8 years': '> 5 years',
            '9 years': '> 5 years',
            '10 years': '> 5 years',
        }
        mapped_ttm = ttm_mapping.get(time_to_maturity, time_to_maturity)
        query_df = query_df[query_df['Time to Maturity'] == mapped_ttm]
        if query_df.empty:
            return f"No data found for Time to Maturity: {time_to_maturity}"

    # Region filter
    if region:
        region = region.lower().strip()
        query_df = query_df[query_df['Region'] == region]
        if query_df.empty:
            return f"No data found for Region: {region}"

    # FI_NonFI filter
    if fi_nonfi:
        fi_nonfi = fi_nonfi.lower().strip()
        query_df = query_df[query_df['FI_NonFI'] == fi_nonfi]
        if query_df.empty:
            return f"No data found for FI_NonFI: {fi_nonfi}"

    # IG_NonIG filter
    if ig_nonig:
        ig_nonig = ig_nonig.lower().strip()
        query_df = query_df[query_df['IG_NonIG'] == ig_nonig]
        if query_df.empty:
            return f"No data found for IG_NonIG: {ig_nonig}"

    if query_df.empty:
        return "No data found for the given parameters."

    # Limit DataFrame to first 10 columns
    query_df = query_df.iloc[:, :10]

    # Display the result DataFrame
    display(query_df)

    return "Here are the results based on your query."
